"""
Test: Hierarchical Multi-Agent Orchestration

This test demonstrates what the user is asking for:
- Hand a high-level task to ControlAgent (System 2)
- ControlAgent decomposes and routes to appropriate System 1 agents
- ResearchAgent handles research/analysis
- DeveloperAgent handles code generation
- ControlAgent synthesizes all results

This is the PROPER hierarchical approach vs directly calling DeveloperAgent.

Author: BMad
Date: 2025-10-19
"""

import sys
from pathlib import Path

# Add project to path
sys.path.insert(0, str(Path(__file__).parent))

from fractal_agent.workflows.multi_agent_workflow import run_multi_agent_workflow


def test_simple_orchestration():
    """Test with a simple mixed task."""
    print("=" * 80)
    print("TEST 1: Simple Mixed Task (Research + Code)")
    print("=" * 80)
    print()

    result = run_multi_agent_workflow(
        main_task="Create an ObsidianVault class in Python for managing markdown files. Include methods for creating files with frontmatter and Git sync."
    )

    print("\n" + "=" * 80)
    print("RESULTS:")
    print("=" * 80)

    # Show which agents handled which subtasks
    agent_counts = {"ResearchAgent": 0, "DeveloperAgent": 0}
    for sr in result['control_result'].subtask_results:
        agent_type = sr['result'].get('agent_type', 'Unknown')
        agent_counts[agent_type] = agent_counts.get(agent_type, 0) + 1

    print(f"Agent Distribution:")
    for agent, count in agent_counts.items():
        print(f"  {agent}: {count} subtasks")

    print(f"\nFinal Report Length: {len(result['final_report'])} characters")

    return result


def test_phase4_component():
    """
    Test with an actual Phase 4 component request.

    This demonstrates the user's desired workflow:
    1. Hand "implement Phase 4 component" to ControlAgent
    2. ControlAgent decomposes (research requirements, design, implement, test)
    3. Routes research to ResearchAgent, code to DeveloperAgent
    4. Synthesizes complete implementation plan
    """
    print("\n\n" + "=" * 80)
    print("TEST 2: Phase 4 Component (Full Orchestration)")
    print("=" * 80)
    print()
    print("Task: Implement ObsidianVault class for Phase 4 human review workflow")
    print()

    # Load Phase 4 plan as context
    phase4_plan = Path(__file__).parent / "PHASE4_PLAN.md"
    if phase4_plan.exists():
        with open(phase4_plan, 'r') as f:
            plan_content = f.read()[:1000]  # First 1000 chars as context
    else:
        plan_content = "Phase 4: Coordination & Human Review"

    task_with_context = f"""
Implement the ObsidianVault class for Phase 4 human review workflow.

CONTEXT FROM PHASE4_PLAN.md:
{plan_content}

REQUIREMENTS:
- Create ObsidianVault class for managing Obsidian vault structure
- Methods: initialize_vault(), create_from_template(), move_to_reviewed(), sync_to_git()
- Use pathlib for file operations
- Include comprehensive docstrings and type hints
- Generate tests for the implementation
"""

    result = run_multi_agent_workflow(main_task=task_with_context)

    print("\n" + "=" * 80)
    print("HIERARCHICAL ORCHESTRATION RESULTS:")
    print("=" * 80)

    # Analyze agent distribution
    agent_counts = {"ResearchAgent": 0, "DeveloperAgent": 0}
    code_generated = False

    print("\nSubtask Breakdown:")
    for i, sr in enumerate(result['control_result'].subtask_results, 1):
        agent_type = sr['result'].get('agent_type', 'Unknown')
        agent_counts[agent_type] = agent_counts.get(agent_type, 0) + 1
        summary = sr['result'].get('result_summary', 'No summary')

        print(f"{i}. {sr['subtask']}")
        print(f"   → Routed to: {agent_type}")
        print(f"   → {summary}")

        if agent_type == "DeveloperAgent" and sr['result'].get('code'):
            code_generated = True

    print(f"\nAgent Distribution:")
    for agent, count in agent_counts.items():
        print(f"  {agent}: {count} subtasks")

    print(f"\nCode Generated: {'✅ Yes' if code_generated else '❌ No'}")
    print(f"Final Report: {len(result['final_report'])} characters")

    print("\n" + "=" * 80)
    print("VERDICT:")
    print("=" * 80)

    if code_generated and agent_counts["DeveloperAgent"] > 0 and agent_counts["ResearchAgent"] >= 0:
        print("✅ SUCCESS: Hierarchical orchestration working!")
        print()
        print("The system demonstrates:")
        print("  1. ControlAgent successfully decomposed high-level task")
        print("  2. Intelligent routing to both ResearchAgent and DeveloperAgent")
        print("  3. Code was generated by DeveloperAgent")
        print("  4. Results synthesized into coherent plan")
        print()
        print("This is the CORRECT abstraction level for 'Implement Phase 4'")
        return 0
    else:
        print("⚠️  PARTIAL: Orchestration incomplete")
        return 1


if __name__ == "__main__":
    import logging
    logging.basicConfig(level=logging.WARNING)  # Reduce noise

    print("=" * 80)
    print("HIERARCHICAL MULTI-AGENT ORCHESTRATION TEST")
    print("=" * 80)
    print()
    print("This demonstrates the proper way to use the system:")
    print("- User hands high-level task to ControlAgent (System 2)")
    print("- ControlAgent orchestrates System 1 agents (Research + Developer)")
    print("- NOT directly calling DeveloperAgent (wrong abstraction level)")
    print()
    print("=" * 80)
    print()

    # Run simple test first
    test_simple_orchestration()

    # Run Phase 4 component test
    exit_code = test_phase4_component()

    exit(exit_code)
